/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "directory_service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace elasticmem { namespace directory {

int _krpc_perm_optionsValues[] = {
  rpc_replace,
  rpc_add,
  rpc_remove
};
const char* _krpc_perm_optionsNames[] = {
  "rpc_replace",
  "rpc_add",
  "rpc_remove"
};
const std::map<int, const char*> _rpc_perm_options_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _krpc_perm_optionsValues, _krpc_perm_optionsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_perm_options val) {
  std::map<int, const char*>::const_iterator it = _rpc_perm_options_VALUES_TO_NAMES.find(val);
  if (it != _rpc_perm_options_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _krpc_file_typeValues[] = {
  rpc_none,
  rpc_regular,
  rpc_directory
};
const char* _krpc_file_typeNames[] = {
  "rpc_none",
  "rpc_regular",
  "rpc_directory"
};
const std::map<int, const char*> _rpc_file_type_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _krpc_file_typeValues, _krpc_file_typeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_file_type val) {
  std::map<int, const char*>::const_iterator it = _rpc_file_type_VALUES_TO_NAMES.find(val);
  if (it != _rpc_file_type_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _krpc_storage_modeValues[] = {
  rpc_in_memory,
  rpc_in_memory_grace,
  rpc_flushing,
  rpc_on_disk
};
const char* _krpc_storage_modeNames[] = {
  "rpc_in_memory",
  "rpc_in_memory_grace",
  "rpc_flushing",
  "rpc_on_disk"
};
const std::map<int, const char*> _rpc_storage_mode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _krpc_storage_modeValues, _krpc_storage_modeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const rpc_storage_mode val) {
  std::map<int, const char*>::const_iterator it = _rpc_storage_mode_VALUES_TO_NAMES.find(val);
  if (it != _rpc_storage_mode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


rpc_file_status::~rpc_file_status() throw() {
}


void rpc_file_status::__set_type(const rpc_file_type val) {
  this->type = val;
}

void rpc_file_status::__set_permissions(const rpc_perms val) {
  this->permissions = val;
}

void rpc_file_status::__set_last_write_time(const int64_t val) {
  this->last_write_time = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_file_status& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_file_status &a, rpc_file_status &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.permissions, b.permissions);
  swap(a.last_write_time, b.last_write_time);
}

rpc_file_status::rpc_file_status(const rpc_file_status& other1) {
  type = other1.type;
  permissions = other1.permissions;
  last_write_time = other1.last_write_time;
}
rpc_file_status& rpc_file_status::operator=(const rpc_file_status& other2) {
  type = other2.type;
  permissions = other2.permissions;
  last_write_time = other2.last_write_time;
  return *this;
}
void rpc_file_status::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_file_status(";
  out << "type=" << to_string(type);
  out << ", " << "permissions=" << to_string(permissions);
  out << ", " << "last_write_time=" << to_string(last_write_time);
  out << ")";
}


rpc_data_status::~rpc_data_status() throw() {
}


void rpc_data_status::__set_storage_mode(const rpc_storage_mode val) {
  this->storage_mode = val;
}

void rpc_data_status::__set_persistent_store_prefix(const std::string& val) {
  this->persistent_store_prefix = val;
}

void rpc_data_status::__set_data_blocks(const std::vector<std::string> & val) {
  this->data_blocks = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_data_status& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_data_status &a, rpc_data_status &b) {
  using ::std::swap;
  swap(a.storage_mode, b.storage_mode);
  swap(a.persistent_store_prefix, b.persistent_store_prefix);
  swap(a.data_blocks, b.data_blocks);
}

rpc_data_status::rpc_data_status(const rpc_data_status& other10) {
  storage_mode = other10.storage_mode;
  persistent_store_prefix = other10.persistent_store_prefix;
  data_blocks = other10.data_blocks;
}
rpc_data_status& rpc_data_status::operator=(const rpc_data_status& other11) {
  storage_mode = other11.storage_mode;
  persistent_store_prefix = other11.persistent_store_prefix;
  data_blocks = other11.data_blocks;
  return *this;
}
void rpc_data_status::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_data_status(";
  out << "storage_mode=" << to_string(storage_mode);
  out << ", " << "persistent_store_prefix=" << to_string(persistent_store_prefix);
  out << ", " << "data_blocks=" << to_string(data_blocks);
  out << ")";
}


rpc_dir_entry::~rpc_dir_entry() throw() {
}


void rpc_dir_entry::__set_name(const std::string& val) {
  this->name = val;
}

void rpc_dir_entry::__set_status(const rpc_file_status& val) {
  this->status = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_dir_entry& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_dir_entry &a, rpc_dir_entry &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.status, b.status);
}

rpc_dir_entry::rpc_dir_entry(const rpc_dir_entry& other12) {
  name = other12.name;
  status = other12.status;
}
rpc_dir_entry& rpc_dir_entry::operator=(const rpc_dir_entry& other13) {
  name = other13.name;
  status = other13.status;
  return *this;
}
void rpc_dir_entry::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_dir_entry(";
  out << "name=" << to_string(name);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


directory_rpc_service_exception::~directory_rpc_service_exception() throw() {
}


void directory_rpc_service_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const directory_rpc_service_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(directory_rpc_service_exception &a, directory_rpc_service_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
}

directory_rpc_service_exception::directory_rpc_service_exception(const directory_rpc_service_exception& other14) : TException() {
  msg = other14.msg;
}
directory_rpc_service_exception& directory_rpc_service_exception::operator=(const directory_rpc_service_exception& other15) {
  msg = other15.msg;
  return *this;
}
void directory_rpc_service_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "directory_rpc_service_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* directory_rpc_service_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: directory_rpc_service_exception";
  }
}


rpc_file_metadata::~rpc_file_metadata() throw() {
}


void rpc_file_metadata::__set_path(const std::string& val) {
  this->path = val;
}

void rpc_file_metadata::__set_bytes(const int64_t val) {
  this->bytes = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_file_metadata& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_file_metadata &a, rpc_file_metadata &b) {
  using ::std::swap;
  swap(a.path, b.path);
  swap(a.bytes, b.bytes);
}

rpc_file_metadata::rpc_file_metadata(const rpc_file_metadata& other16) {
  path = other16.path;
  bytes = other16.bytes;
}
rpc_file_metadata& rpc_file_metadata::operator=(const rpc_file_metadata& other17) {
  path = other17.path;
  bytes = other17.bytes;
  return *this;
}
void rpc_file_metadata::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_file_metadata(";
  out << "path=" << to_string(path);
  out << ", " << "bytes=" << to_string(bytes);
  out << ")";
}


lease_update::~lease_update() throw() {
}


void lease_update::__set_to_renew(const std::vector<rpc_file_metadata> & val) {
  this->to_renew = val;
}

void lease_update::__set_to_flush(const std::vector<std::string> & val) {
  this->to_flush = val;
}

void lease_update::__set_to_remove(const std::vector<std::string> & val) {
  this->to_remove = val;
}
std::ostream& operator<<(std::ostream& out, const lease_update& obj)
{
  obj.printTo(out);
  return out;
}


void swap(lease_update &a, lease_update &b) {
  using ::std::swap;
  swap(a.to_renew, b.to_renew);
  swap(a.to_flush, b.to_flush);
  swap(a.to_remove, b.to_remove);
}

lease_update::lease_update(const lease_update& other36) {
  to_renew = other36.to_renew;
  to_flush = other36.to_flush;
  to_remove = other36.to_remove;
}
lease_update& lease_update::operator=(const lease_update& other37) {
  to_renew = other37.to_renew;
  to_flush = other37.to_flush;
  to_remove = other37.to_remove;
  return *this;
}
void lease_update::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "lease_update(";
  out << "to_renew=" << to_string(to_renew);
  out << ", " << "to_flush=" << to_string(to_flush);
  out << ", " << "to_remove=" << to_string(to_remove);
  out << ")";
}


lease_ack::~lease_ack() throw() {
}


void lease_ack::__set_renewed(const std::vector<rpc_file_metadata> & val) {
  this->renewed = val;
}

void lease_ack::__set_flushed(const int64_t val) {
  this->flushed = val;
}

void lease_ack::__set_removed(const int64_t val) {
  this->removed = val;
}
std::ostream& operator<<(std::ostream& out, const lease_ack& obj)
{
  obj.printTo(out);
  return out;
}


void swap(lease_ack &a, lease_ack &b) {
  using ::std::swap;
  swap(a.renewed, b.renewed);
  swap(a.flushed, b.flushed);
  swap(a.removed, b.removed);
}

lease_ack::lease_ack(const lease_ack& other44) {
  renewed = other44.renewed;
  flushed = other44.flushed;
  removed = other44.removed;
}
lease_ack& lease_ack::operator=(const lease_ack& other45) {
  renewed = other45.renewed;
  flushed = other45.flushed;
  removed = other45.removed;
  return *this;
}
void lease_ack::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "lease_ack(";
  out << "renewed=" << to_string(renewed);
  out << ", " << "flushed=" << to_string(flushed);
  out << ", " << "removed=" << to_string(removed);
  out << ")";
}


directory_lease_service_exception::~directory_lease_service_exception() throw() {
}


void directory_lease_service_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const directory_lease_service_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(directory_lease_service_exception &a, directory_lease_service_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

directory_lease_service_exception::directory_lease_service_exception(const directory_lease_service_exception& other46) : TException() {
  msg = other46.msg;
  __isset = other46.__isset;
}
directory_lease_service_exception& directory_lease_service_exception::operator=(const directory_lease_service_exception& other47) {
  msg = other47.msg;
  __isset = other47.__isset;
  return *this;
}
void directory_lease_service_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "directory_lease_service_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* directory_lease_service_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: directory_lease_service_exception";
  }
}

}} // namespace
