/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef directory_service_TYPES_TCC
#define directory_service_TYPES_TCC

#include "directory_service_types.h"

namespace elasticmem {
namespace directory {

template<class Protocol_>
uint32_t rpc_file_status::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_type = false;
  bool isset_permissions = false;
  bool isset_last_write_time = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (rpc_file_type) ecast0;
          isset_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->permissions);
          isset_permissions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->last_write_time);
          isset_last_write_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_type)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_permissions)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_last_write_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template<class Protocol_>
uint32_t rpc_file_status::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_file_status");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t) this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("permissions", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->permissions);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_write_time", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->last_write_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template<class Protocol_>
uint32_t rpc_data_status::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_storage_mode = false;
  bool isset_persistent_store_prefix = false;
  bool isset_data_blocks = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->storage_mode = (rpc_storage_mode) ecast3;
          isset_storage_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->persistent_store_prefix);
          isset_persistent_store_prefix = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data_blocks.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->data_blocks.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8) {
              xfer += iprot->readString(this->data_blocks[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          isset_data_blocks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_storage_mode)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_persistent_store_prefix)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_data_blocks)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template<class Protocol_>
uint32_t rpc_data_status::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_data_status");

  xfer += oprot->writeFieldBegin("storage_mode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t) this->storage_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("persistent_store_prefix", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->persistent_store_prefix);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_blocks", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer +=
        oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->data_blocks.size()));
    std::vector<std::string>::const_iterator _iter9;
    for (_iter9 = this->data_blocks.begin(); _iter9 != this->data_blocks.end(); ++_iter9) {
      xfer += oprot->writeString((*_iter9));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template<class Protocol_>
uint32_t rpc_dir_entry::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_name = false;
  bool isset_status = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          isset_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          isset_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_name)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_status)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template<class Protocol_>
uint32_t rpc_dir_entry::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_dir_entry");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template<class Protocol_>
uint32_t directory_rpc_service_exception::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_msg = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          isset_msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_msg)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template<class Protocol_>
uint32_t directory_rpc_service_exception::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("directory_rpc_service_exception");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template<class Protocol_>
uint32_t rpc_lease_update::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_to_renew = false;
  bool isset_to_flush = false;
  bool isset_to_remove = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->to_renew.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _etype19;
            xfer += iprot->readListBegin(_etype19, _size16);
            this->to_renew.resize(_size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20) {
              xfer += iprot->readString(this->to_renew[_i20]);
            }
            xfer += iprot->readListEnd();
          }
          isset_to_renew = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->to_flush.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->to_flush.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25) {
              xfer += iprot->readString(this->to_flush[_i25]);
            }
            xfer += iprot->readListEnd();
          }
          isset_to_flush = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->to_remove.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->to_remove.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30) {
              xfer += iprot->readString(this->to_remove[_i30]);
            }
            xfer += iprot->readListEnd();
          }
          isset_to_remove = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_to_renew)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_to_flush)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_to_remove)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template<class Protocol_>
uint32_t rpc_lease_update::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_lease_update");

  xfer += oprot->writeFieldBegin("to_renew", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->to_renew.size()));
    std::vector<std::string>::const_iterator _iter31;
    for (_iter31 = this->to_renew.begin(); _iter31 != this->to_renew.end(); ++_iter31) {
      xfer += oprot->writeString((*_iter31));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to_flush", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->to_flush.size()));
    std::vector<std::string>::const_iterator _iter32;
    for (_iter32 = this->to_flush.begin(); _iter32 != this->to_flush.end(); ++_iter32) {
      xfer += oprot->writeString((*_iter32));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("to_remove", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->to_remove.size()));
    std::vector<std::string>::const_iterator _iter33;
    for (_iter33 = this->to_remove.begin(); _iter33 != this->to_remove.end(); ++_iter33) {
      xfer += oprot->writeString((*_iter33));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template<class Protocol_>
uint32_t rpc_lease_ack::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_renewed = false;
  bool isset_flushed = false;
  bool isset_removed = false;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->renewed);
          isset_renewed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->flushed);
          isset_flushed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->removed);
          isset_removed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_renewed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_flushed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_removed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

template<class Protocol_>
uint32_t rpc_lease_ack::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("rpc_lease_ack");

  xfer += oprot->writeFieldBegin("renewed", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->renewed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flushed", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->flushed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("removed", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->removed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

template<class Protocol_>
uint32_t directory_lease_service_exception::read(Protocol_ *iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

template<class Protocol_>
uint32_t directory_lease_service_exception::write(Protocol_ *oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("directory_lease_service_exception");

  xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->msg);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

}
} // namespace

#endif
