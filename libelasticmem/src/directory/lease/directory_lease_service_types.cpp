/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "directory_lease_service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace elasticmem { namespace directory {


rpc_lease_update::~rpc_lease_update() throw() {
}


void rpc_lease_update::__set_to_renew(const std::vector<std::string> & val) {
  this->to_renew = val;
}

void rpc_lease_update::__set_to_flush(const std::vector<std::string> & val) {
  this->to_flush = val;
}

void rpc_lease_update::__set_to_remove(const std::vector<std::string> & val) {
  this->to_remove = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_lease_update& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_lease_update &a, rpc_lease_update &b) {
  using ::std::swap;
  swap(a.to_renew, b.to_renew);
  swap(a.to_flush, b.to_flush);
  swap(a.to_remove, b.to_remove);
}

rpc_lease_update::rpc_lease_update(const rpc_lease_update& other18) {
  to_renew = other18.to_renew;
  to_flush = other18.to_flush;
  to_remove = other18.to_remove;
}
rpc_lease_update& rpc_lease_update::operator=(const rpc_lease_update& other19) {
  to_renew = other19.to_renew;
  to_flush = other19.to_flush;
  to_remove = other19.to_remove;
  return *this;
}
void rpc_lease_update::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_lease_update(";
  out << "to_renew=" << to_string(to_renew);
  out << ", " << "to_flush=" << to_string(to_flush);
  out << ", " << "to_remove=" << to_string(to_remove);
  out << ")";
}


rpc_lease_ack::~rpc_lease_ack() throw() {
}


void rpc_lease_ack::__set_renewed(const int64_t val) {
  this->renewed = val;
}

void rpc_lease_ack::__set_flushed(const int64_t val) {
  this->flushed = val;
}

void rpc_lease_ack::__set_removed(const int64_t val) {
  this->removed = val;
}
std::ostream& operator<<(std::ostream& out, const rpc_lease_ack& obj)
{
  obj.printTo(out);
  return out;
}


void swap(rpc_lease_ack &a, rpc_lease_ack &b) {
  using ::std::swap;
  swap(a.renewed, b.renewed);
  swap(a.flushed, b.flushed);
  swap(a.removed, b.removed);
}

rpc_lease_ack::rpc_lease_ack(const rpc_lease_ack& other20) {
  renewed = other20.renewed;
  flushed = other20.flushed;
  removed = other20.removed;
}
rpc_lease_ack& rpc_lease_ack::operator=(const rpc_lease_ack& other21) {
  renewed = other21.renewed;
  flushed = other21.flushed;
  removed = other21.removed;
  return *this;
}
void rpc_lease_ack::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "rpc_lease_ack(";
  out << "renewed=" << to_string(renewed);
  out << ", " << "flushed=" << to_string(flushed);
  out << ", " << "removed=" << to_string(removed);
  out << ")";
}


directory_lease_service_exception::~directory_lease_service_exception() throw() {
}


void directory_lease_service_exception::__set_msg(const std::string& val) {
  this->msg = val;
}
std::ostream& operator<<(std::ostream& out, const directory_lease_service_exception& obj)
{
  obj.printTo(out);
  return out;
}


void swap(directory_lease_service_exception &a, directory_lease_service_exception &b) {
  using ::std::swap;
  swap(a.msg, b.msg);
  swap(a.__isset, b.__isset);
}

directory_lease_service_exception::directory_lease_service_exception(const directory_lease_service_exception& other22) : TException() {
  msg = other22.msg;
  __isset = other22.__isset;
}
directory_lease_service_exception& directory_lease_service_exception::operator=(const directory_lease_service_exception& other23) {
  msg = other23.msg;
  __isset = other23.__isset;
  return *this;
}
void directory_lease_service_exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "directory_lease_service_exception(";
  out << "msg=" << to_string(msg);
  out << ")";
}

const char* directory_lease_service_exception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: directory_lease_service_exception";
  }
}

}} // namespace
